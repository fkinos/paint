#include <SDL2/SDL.h>
#include <SDL2/SDL_events.h>
#include <SDL2/SDL_keycode.h>
#include <SDL2/SDL_pixels.h>
#include <stdio.h>
#include <math.h>
#include <time.h>

#define TITLE "PAINT"
#define WIDTH 320
#define HEIGHT 200

#define BLACK 0x000000
#define WHITE 0xFFFFFF
#define RED 0x9F4E44
#define CYAN 0x6ABFC6
#define PURPLE 0xA057A3
#define GREEN 0x5CAB5E
#define BLUE 0x50459B
#define YELLOW 0xC9D487

static int zoom = 1;
static int reqdraw;

static SDL_Window *gWindow = NULL;
static SDL_Renderer *gRenderer = NULL;
static SDL_Texture *gTexture = NULL;
static unsigned int *pixels;

unsigned char font[] = {
  /* FIRST SET */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  */
  0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00, /* ! */
  0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, /* " */
  0x66, 0x66, 0xff, 0x66, 0xff, 0x66, 0x66, 0x00, /* # */
  0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00, /* $ */
  0x62, 0x66, 0x0c, 0x18, 0x30, 0x66, 0x46, 0x00, /* % */
  0x3c, 0x66, 0x3c, 0x38, 0x67, 0x66, 0x3f, 0x00, /* & */
  0x06, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, /* ' */
  0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00, /* ( */
  0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00, /* ) */
  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, /* * */
  0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, /* + */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00, /* , */
  0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, /* - */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, /* . */
  0x00, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, /* / */
  0x3c, 0x66, 0x6e, 0x76, 0x66, 0x66, 0x3c, 0x00, /* 0 */
  0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7e, 0x00, /* 1 */
  0x3c, 0x66, 0x06, 0x0c, 0x30, 0x60, 0x7e, 0x00, /* 2 */
  0x3c, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00, /* 3 */
  0x06, 0x0e, 0x1e, 0x66, 0x7f, 0x06, 0x06, 0x00, /* 4 */
  0x7e, 0x60, 0x7c, 0x06, 0x06, 0x66, 0x3c, 0x00, /* 5 */
  0x3c, 0x66, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00, /* 6 */
  0x7e, 0x66, 0x0c, 0x18, 0x18, 0x18, 0x18, 0x00, /* 7 */
  0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00, /* 8 */
  0x3c, 0x66, 0x66, 0x3e, 0x06, 0x66, 0x3c, 0x00, /* 9 */
  0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, /* : */
  0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30, /* ; */
  0x0e, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0e, 0x00, /* < */
  0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, /* = */
  0x70, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x70, 0x00, /* > */
  0x3c, 0x66, 0x06, 0x0c, 0x18, 0x00, 0x18, 0x00, /* ? */
  0x3c, 0x66, 0x6e, 0x6e, 0x60, 0x62, 0x3c, 0x00, /* @ */
  /* uppercase letters */
  0x18, 0x3c, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00, /* A */
  0x7c, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x7c, 0x00, /* B */
  0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3c, 0x00, /* C */
  0x78, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0x78, 0x00, /* D */
  0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7e, 0x00, /* E */
  0x7e, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00, /* F */
  0x3c, 0x66, 0x60, 0x6e, 0x66, 0x66, 0x3c, 0x00, /* G */
  0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00, /* H */
  0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, /* I */
  0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x6c, 0x38, 0x00, /* J */
  0x66, 0x6c, 0x78, 0x70, 0x78, 0x6c, 0x66, 0x00, /* K */
  0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00, /* L */
  0x63, 0x77, 0x7f, 0x6b, 0x63, 0x63, 0x63, 0x00, /* M */
  0x66, 0x76, 0x7e, 0x7e, 0x6e, 0x66, 0x66, 0x00, /* N */
  0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, /* O */
  0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x00, /* P */
  0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x0e, 0x00, /* Q */
  0x7c, 0x66, 0x66, 0x7c, 0x78, 0x6c, 0x66, 0x00, /* R */
  0x3c, 0x66, 0x60, 0x3c, 0x06, 0x66, 0x3c, 0x00, /* S */
  0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, /* T */
  0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, /* U */
  0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, /* V */
  0x63, 0x63, 0x63, 0x6b, 0x7f, 0x77, 0x63, 0x00, /* W */
  0x66, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x66, 0x00, /* X */
  0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00, /* Y */
  0x7e, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00, /* Z */
  0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, /* [ */
  0x0c, 0x12, 0x30, 0x7c, 0x30, 0x62, 0xfc, 0x00, /* \ */
  0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, /* [ */
  0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, /* ^ */
  0x00, 0x10, 0x30, 0x7f, 0x7f, 0x30, 0x10, 0x00, /* _ */
  0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, /* ` */
  /* lowercase letters */
  0x00, 0x00, 0x3c, 0x06, 0x3e, 0x66, 0x3e, 0x00, /* a */
  0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x00, /* b */
  0x00, 0x00, 0x3c, 0x60, 0x60, 0x60, 0x3c, 0x00, /* c */
  0x00, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00, /* d */
  0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00, /* e */
  0x00, 0x0e, 0x18, 0x3e, 0x18, 0x18, 0x18, 0x00, /* f */
  0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x7c, /* g */
  0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x00, /* h */
  0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x3c, 0x00, /* i */
  0x00, 0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x3c, /* j */
  0x00, 0x60, 0x60, 0x6c, 0x78, 0x6c, 0x66, 0x00, /* k */
  0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, /* l */
  0x00, 0x00, 0x66, 0x7f, 0x7f, 0x6b, 0x63, 0x00, /* m */
  0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00, /* n */
  0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00, /* o */
  0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, /* p */
  0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x06, /* q */
  0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x00, /* r */
  0x00, 0x00, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x00, /* s */
  0x00, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x0e, 0x00, /* t */
  0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00, /* u */
  0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, /* v */
  0x00, 0x00, 0x63, 0x6b, 0x7f, 0x3e, 0x36, 0x00, /* w */
  0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00, /* x */
  0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x0c, 0x78, /* y */
  0x00, 0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00, /* z */
  0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, /* cross */
  0xc0, 0xc0, 0x30, 0x30, 0xc0, 0xc0, 0x30, 0x30, /* dotted left */
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* vertical line */
  0x00, 0x00, 0x03, 0x3e, 0x76, 0x36, 0x36, 0x00, /* pi */
  0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, /* half right diagonal */

  /* SECOND SET */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  */
  0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00, /* ! */
  0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, /* " */
  0x66, 0x66, 0xff, 0x66, 0xff, 0x66, 0x66, 0x00, /* # */
  0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00, /* $ */
  0x62, 0x66, 0x0c, 0x18, 0x30, 0x66, 0x46, 0x00, /* % */
  0x3c, 0x66, 0x3c, 0x38, 0x67, 0x66, 0x3f, 0x00, /* & */
  0x06, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, /* ' */
  0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00, /* ( */
  0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00, /* ) */
  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, /* * */
  0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, /* + */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00, /* , */
  0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, /* - */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, /* . */
  0x00, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, /* / */
  0x3c, 0x66, 0x6e, 0x76, 0x66, 0x66, 0x3c, 0x00, /* 0 */
  0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7e, 0x00, /* 1 */
  0x3c, 0x66, 0x06, 0x0c, 0x30, 0x60, 0x7e, 0x00, /* 2 */
  0x3c, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00, /* 3 */
  0x06, 0x0e, 0x1e, 0x66, 0x7f, 0x06, 0x06, 0x00, /* 4 */
  0x7e, 0x60, 0x7c, 0x06, 0x06, 0x66, 0x3c, 0x00, /* 5 */
  0x3c, 0x66, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00, /* 6 */
  0x7e, 0x66, 0x0c, 0x18, 0x18, 0x18, 0x18, 0x00, /* 7 */
  0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00, /* 8 */
  0x3c, 0x66, 0x66, 0x3e, 0x06, 0x66, 0x3c, 0x00, /* 9 */
  0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, /* : */
  0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30, /* ; */
  0x0e, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0e, 0x00, /* < */
  0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, /* = */
  0x70, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x70, 0x00, /* > */
  0x3c, 0x66, 0x06, 0x0c, 0x18, 0x00, 0x18, 0x00, /* ? */
  0x3c, 0x66, 0x6e, 0x6e, 0x60, 0x62, 0x3c, 0x00, /* @ */
  /* symbols */
  0x08, 0x1c, 0x3e, 0x7f, 0x7f, 0x1c, 0x3e, 0x00, /* A */
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, /* B */
  0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, /* C */
  0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, /* D */
  0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, /* E */
  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, /* F */
  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, /* G */
  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, /* H */
  0x00, 0x00, 0x00, 0xe0, 0xf0, 0x38, 0x18, 0x18, /* I */
  0x18, 0x18, 0x1c, 0x0f, 0x07, 0x00, 0x00, 0x00, /* J */
  0x18, 0x18, 0x38, 0xf0, 0xe0, 0x00, 0x00, 0x00, /* K */
  0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, /* L */
  0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x07, 0x03, /* M */
  0x03, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xc0, /* N */
  0xff, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, /* O */
  0xff, 0xff, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, /* P */
  0x00, 0x3c, 0x7e, 0x7e, 0x7e, 0x7e, 0x3c, 0x00, /* Q */
  0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, /* R */
  0x36, 0x7f, 0x7f, 0x7f, 0x3e, 0x1c, 0x08, 0x00, /* S */
  0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, /* T */
  0x00, 0x00, 0x00, 0x07, 0x0f, 0x1c, 0x18, 0x18, /* U */
  0xc3, 0xe7, 0x7e, 0x3c, 0x3c, 0x7e, 0xe7, 0xc3, /* V */
  0x00, 0x3c, 0x7e, 0x66, 0x66, 0x7e, 0x3c, 0x00, /* W */
  0x18, 0x18, 0x66, 0x66, 0x18, 0x18, 0x3c, 0x00, /* X */
  0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, /* Y */
  0x08, 0x1c, 0x3e, 0x7f, 0x3e, 0x1c, 0x08, 0x00, /* Z */
  0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, /* [ */
  0x0c, 0x12, 0x30, 0x7c, 0x30, 0x62, 0xfc, 0x00, /* \ */
  0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, /* [ */
  0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, /* ^ */
  0x00, 0x10, 0x30, 0x7f, 0x7f, 0x30, 0x10, 0x00, /* _ */

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*  */
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, /* half left */
  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, /* half bottom */
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* top line */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, /* bottom line */
  0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, /* quarter left */
  0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0x33, 0x33, /* checkboard */
  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, /* quarter right */
  0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0x33, 0x33, /* checkboard bottom */
  0xcc, 0x99, 0x33, 0x66, 0xcc, 0x99, 0x33, 0x66, /* diagonal upper-left stripes */
  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, /* quarter right */
  0x18, 0x18, 0x18, 0x1f, 0x1f, 0x18, 0x18, 0x18, /* path straight T left */
  0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, /* bottom-right square */
  0x18, 0x18, 0x18, 0x1f, 0x1f, 0x00, 0x00, 0x00, /* path straight bottom-left corner */
  0x00, 0x00, 0x00, 0xf8, 0xf8, 0x18, 0x18, 0x18, /* path straight upper-right corner */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, /* quarter bottom */
  0x00, 0x00, 0x00, 0x1f, 0x1f, 0x18, 0x18, 0x18, /* path straight upper-left corner */
  0x18, 0x18, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00, /* path straight T bottom */
  0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x18, 0x18, /* path straight T up */
  0x18, 0x18, 0x18, 0xf8, 0xf8, 0x18, 0x18, 0x18, /* path straight T right */
  0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, /* bar 2 to right */
  0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, /* bar 3 to right */
  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, /* bar -3 to left */
  0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* bar 2 to bottom */
  0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, /* bar 3 to bottom */
  0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, /* bar -3 to bottom */
  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff, /* bottom-right frame */
  0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, /* bottom-left square */
  0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, /* upper-right square */
  0x18, 0x18, 0x18, 0xf8, 0xf8, 0x00, 0x00, 0x00, /* path straight bottom-right corner */
  0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, /* upper-left square */
  0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f, /* checkboard x2 */
  0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, /* path straight center horizontal */
};

int abs (int j)
{
  if (j == 0) return 0;
  if (j > 0) return j;
  return -j;
}

static void
clear_screen (unsigned int color)
{
  int i;
  for (i = 0; i < WIDTH * HEIGHT; i++)
    pixels[i] = color;
}

static void
draw_pixel (int x, int y, unsigned int color)
{
  if (x < WIDTH && y < HEIGHT && x >= 0 && y >= 0)
    pixels[y * WIDTH + x] = color;
}

static void
draw_rect (int x, int y, int w, int h, unsigned int color)
{
  int i, j;

  for (i = x; i < x + w; i++) {
    for (j = y; j < y + h; j++) {
      draw_pixel (i, j, color);
    }
  }
}

static void
draw_icn (int x, int y, unsigned char *sprite, unsigned int color)
{
  int y2 = y + 8, h;

  for (; y < y2; y++, sprite++) {
    for (h = 0; h < 8; h++) {
      if (*sprite << h & 0x80)
        draw_pixel (x + h, y, color);
    }
  }
}

void
draw_letter (int x, int y, int letter, unsigned int fg_color, unsigned int bg_color)
{
  int idx = letter - 32;

  draw_rect (x, y, 8, 8, bg_color);
  draw_icn (x, y, font + (idx * 8), fg_color);
}

void
draw_string (int x, int y, char *string, unsigned int fg_color, unsigned int bg_color)
{
  int i;

  for (i = 0; i < strlen (string); i++) {
    draw_letter (x + (i * 8), y, string[i], fg_color, bg_color);
  }
}

static void
set_window_size (SDL_Window *window, int w, int h)
{
  SDL_Point win_old;

  SDL_GetWindowSize (window, &win_old.x, &win_old.y);

  if (w == win_old.x && h == win_old.y) return;

  SDL_RenderClear (gRenderer);
  SDL_SetWindowSize (window, w, h);
}

static void
set_zoom (int z, int win)
{
  if (z < 1) return;

  if (win)
    set_window_size (gWindow, WIDTH * z, HEIGHT * z);

  zoom = z;
}

static void
emu_end (void)
{
    free (pixels);

    SDL_DestroyTexture (gTexture), gTexture = NULL;
    SDL_DestroyRenderer (gRenderer), gRenderer = NULL;
    SDL_DestroyWindow (gWindow), gWindow = NULL;

    SDL_Quit ();

    exit(0);
}

static int
init (void)
{
    if(SDL_Init(SDL_INIT_VIDEO) < 0)
      fprintf (stderr, "INIT ERROR: %s\n", SDL_GetError ());

    gWindow = SDL_CreateWindow (TITLE,
                                SDL_WINDOWPOS_UNDEFINED,
                                SDL_WINDOWPOS_UNDEFINED,
                                WIDTH, HEIGHT,
                                SDL_WINDOW_SHOWN);
    if (gWindow == NULL)
      fprintf (stderr, "WINDOW ERROR: %s\n", SDL_GetError ());

    gRenderer = SDL_CreateRenderer (gWindow, -1, 0);
    if (gRenderer == NULL)
      fprintf (stderr, "RENDERER ERROR: %s\n", SDL_GetError ());

    gTexture = SDL_CreateTexture(gRenderer,
                                 SDL_PIXELFORMAT_ARGB8888,
                                 SDL_TEXTUREACCESS_STATIC,
                                 WIDTH, HEIGHT);
    if (gTexture == NULL)
      fprintf (stderr, "TEXTURE ERROR: %s\n", SDL_GetError ());

    pixels = (unsigned int *)malloc (WIDTH * HEIGHT * sizeof (unsigned int));
    if (pixels == NULL)
      fprintf (stderr, "PIXELS ERROR: %s\n", "Failed to allocate memory");

    SDL_ShowCursor (1);

    return 1;
}

typedef struct {
  int brush;
  int fg;
  int bg;
} piece_t;

typedef struct {
  int x, y;
} point_t;

static int frame = 0;
static int last_move = 0;

/* frames to wait before start blinking cursor again */
#define BLINK_DELAY 1000

static point_t cursor;
static piece_t canvas[40][25];
static int brush = 'a';
static int paint = 0;
static int fg_color = WHITE;
static int bg_color = BLACK;
static int set = 0;

void
startup ()
{
  int i, j;

  for (i = 0; i < WIDTH / 8; i++) {
    for (j = 0; j < HEIGHT / 8; j++) {
      canvas[i][j].brush = ' ';
      canvas[i][j].fg = fg_color;
      canvas[i][j].bg = bg_color;
    }
  }

  cursor.x = 0;
  cursor.y = 0;

  clear_screen (BLACK);
}

void
update ()
{
  if (paint) {
    canvas[cursor.x][cursor.y].brush = brush;
    if (set == 1)
      canvas[cursor.x][cursor.y].brush += 96;
    canvas[cursor.x][cursor.y].fg = fg_color;
    canvas[cursor.x][cursor.y].bg = bg_color;
  }

  paint = 0;

  frame += 1;
}

void
save_texture (const char *filename)
{
    int st;
    int format = SDL_PIXELFORMAT_RGBA32;
    SDL_Surface *surf = NULL;

    /* copy pixel data over to surface */
    surf = SDL_CreateRGBSurfaceWithFormatFrom (pixels,
                                               WIDTH,
                                               HEIGHT,
                                               SDL_BITSPERPIXEL (format),
                                               WIDTH * SDL_BYTESPERPIXEL (format),
                                               format);
    if (!surf) {
        SDL_Log ("SURFACE ERROR: %s\n", SDL_GetError ());
        goto cleanup;
    }

    /* save result to an image */
    st = SDL_SaveBMP (surf, filename);
    if (st != 0) {
        SDL_Log ("SAVE ERROR: %s\n", SDL_GetError ());
        goto cleanup;
    }

cleanup:
    SDL_FreeSurface(surf);
}

void
on_keydown (SDL_Event e)
{
  int sym = e.key.keysym.sym;
  SDL_Keymod mods = e.key.keysym.mod;
  int alt = 0;
  int shift = 0;
  int ctrl = 0;

  if (mods & KMOD_ALT) alt = 1;
  if (mods & KMOD_SHIFT) shift = 1;
  if (mods & KMOD_CTRL) ctrl = 1;

  if (ctrl)
    switch (sym) {
    case SDLK_s: save_texture ("image.bmp"); break;
    }

  if (ctrl) set = 1;

  if (alt && shift) {
    switch (sym) {
    case SDLK_0: bg_color = BLACK; break;
    case SDLK_1: bg_color = WHITE; break;
    case SDLK_2: bg_color = RED; break;
    case SDLK_3: bg_color = CYAN; break;
    case SDLK_4: bg_color = PURPLE; break;
    case SDLK_5: bg_color = GREEN; break;
    case SDLK_6: bg_color = BLUE; break;
    case SDLK_7: bg_color = YELLOW; break;
    }
  } else if (alt) {
    switch (sym) {
    case SDLK_0: fg_color = BLACK; break;
    case SDLK_1: fg_color = WHITE; break;
    case SDLK_2: fg_color = RED; break;
    case SDLK_3: fg_color = CYAN; break;
    case SDLK_4: fg_color = PURPLE; break;
    case SDLK_5: fg_color = GREEN; break;
    case SDLK_6: fg_color = BLUE; break;
    case SDLK_7: fg_color = YELLOW; break;
    }
  }

  switch (sym) {
  case SDLK_SPACE: paint = 1; break;

  case SDLK_LEFT: cursor.x -= 1; last_move = frame; break;
  case SDLK_RIGHT: cursor.x += 1; last_move = frame; break;
  case SDLK_UP: cursor.y -= 1; last_move = frame; break;
  case SDLK_DOWN: cursor.y += 1; last_move = frame; break;
  case SDLK_BACKSPACE: brush = ' '; last_move = frame; break;

  case SDLK_F1:
    zoom += 1;
    if (zoom > 3) zoom = 1;
    set_zoom (zoom, 1);
    break;
  }

  /* loop cursor */
  if (cursor.x < 0) cursor.x = WIDTH / 8 - 1;
  if (cursor.x > WIDTH / 8 - 1) cursor.x = 0;
  if (cursor.y < 0) cursor.y = HEIGHT / 8 - 1;
  if (cursor.y > HEIGHT / 8 - 1) cursor.y = 0;
}

void
on_keyup (SDL_Event e)
{
  int sym = e.key.keysym.sym;

  switch (sym) {
  case SDLK_LCTRL:
    set = 0;
    break;
  }
}

void
draw ()
{
  int i, j;
  int blink;
  int start_blink;

  clear_screen (BLACK);

  for (i = 0; i < WIDTH / 8; i++) {
    for (j = 0; j < HEIGHT / 8; j++) {
      draw_letter (i * 8, j * 8, canvas[i][j].brush, canvas[i][j].fg, canvas[i][j].bg);
    }
  }

  blink = (frame / 30) % 2 == 0 ? 1 : 0;
  start_blink = last_move < frame - BLINK_DELAY;

  /* draw cursor */
  /* the cursor allows the user to preview which brush,
     foreground and background color are in use currently.

     blink if user hasn't moved in sometime as it can be
     hard to find your cursor once the canvas is more used.
  */
  draw_letter (cursor.x*8, cursor.y*8, brush + (set ? 96 : 0),
               blink && start_blink ? bg_color : fg_color,
               blink && start_blink ? fg_color : bg_color);
}

int
main (int argc, char *argv[])
{
  Uint32 begintime = 0, endtime = 0, delta = 0;

  if (!init ())
    fprintf (stderr, "INIT ERROR: FAILURE\n");
  set_zoom (1, 1);

  clear_screen (BLACK);

  startup ();

  /* event loop */
  while (1) {
    SDL_Event e;

    /* don't draw if not needed */
    if (!begintime) {
      begintime = SDL_GetTicks ();
    } else {
      delta = endtime - begintime;
    }

    if (delta < 30) SDL_Delay (30 - delta);

    /* gather events from the user and the operation system */
    while (SDL_PollEvent (&e) != 0) {
      switch(e.type) {
      case SDL_QUIT: emu_end (); break;
      case SDL_WINDOWEVENT: reqdraw = 1; break;
      case SDL_KEYDOWN: on_keydown (e); break;
      case SDL_KEYUP: on_keyup (e); break;
      case SDL_TEXTINPUT:
        if (e.key.keysym.mod & KMOD_ALT)
          break;

        if (!(e.text.text[0] == ' '))
          brush = e.text.text[0];
        break;
      }
    }

    update ();
    if (reqdraw)
      draw ();

    /* draw pixels array to SDL texture */
    SDL_UpdateTexture (gTexture, NULL, pixels, WIDTH * sizeof (unsigned int));
    SDL_RenderCopy (gRenderer, gTexture, NULL, NULL);
    SDL_RenderPresent (gRenderer);

    begintime = endtime;
    endtime = SDL_GetTicks ();
  }

  emu_end();

  return 0;
}
